#!/usr/bin/env python3
"""
üß™ TESTE COMPLETO DO SISTEMA DE EXECU√á√ÉO REAL
Testa especificamente as corre√ß√µes implementadas para execu√ß√£o de comandos simples
"""

import asyncio
import pytest
import tempfile
import shutil
import os
import sys
from pathlib import Path
from unittest.mock import Mock, AsyncMock, patch
from typing import Dict, Any

# Add project root to path
sys.path.insert(0, str(Path(__file__).parent))

from gemini_code.interface.enhanced_chat_interface import EnhancedChatInterface
from gemini_code.core.nlp_enhanced import NLPEnhanced, IntentType
from gemini_code.core.autonomous_executor import AutonomousExecutor
from gemini_code.execution.command_executor import CommandExecutor, CommandContext


class TestSystemExecutionFixes:
    """Testa as corre√ß√µes espec√≠ficas implementadas para execu√ß√£o real."""
    
    @pytest.fixture
    def temp_workspace(self):
        """Workspace tempor√°rio para testes."""
        temp_dir = tempfile.mkdtemp()
        yield temp_dir
        shutil.rmtree(temp_dir)
    
    @pytest.fixture
    def mock_gemini_client(self):
        """Mock Gemini client otimizado."""
        client = Mock()
        client.generate_response = AsyncMock(return_value="Mock response from Gemini")
        return client
    
    @pytest.fixture
    def chat_interface(self, temp_workspace, mock_gemini_client):
        """Interface de chat configurada para testes."""
        mock_project_manager = Mock()
        mock_file_manager = Mock()
        
        # Mock do file_manager para criar diret√≥rios
        mock_file_manager.create_directory = Mock(return_value=True)
        mock_file_manager.delete_file = Mock(return_value=True)
        
        chat = EnhancedChatInterface(
            mock_gemini_client,
            mock_project_manager,
            mock_file_manager,
            temp_workspace
        )
        return chat

    @pytest.mark.asyncio
    async def test_simple_folder_creation_flow(self, chat_interface, temp_workspace):
        """üéØ TESTE PRINCIPAL: Cria√ß√£o de pasta simples (caso do usu√°rio)."""
        print("\nüéØ Testando: 'Crie uma pasta chamada ideias'")
        
        # Comando exato que o usu√°rio relatou
        user_input = "Crie uma pasta chamada ideias"
        
        # 1. Testar detec√ß√£o de inten√ß√£o NLP
        nlp_result = await chat_interface.nlp.identify_intent(user_input)
        print(f"üìä NLP detectou: {nlp_result}")
        
        # Deve detectar como CREATE_FILE com alta confian√ßa
        assert nlp_result['intent'] == 'create_file'
        assert nlp_result['confidence'] > 70
        
        # 2. Testar identifica√ß√£o como comando simples
        simple_intent = await chat_interface._identify_simple_execution_intent(user_input)
        print(f"üîç Comando simples detectado: {simple_intent}")
        
        # Deve ser identificado como cria√ß√£o de pasta
        assert simple_intent is not None
        assert simple_intent['type'] == 'create_folder'
        assert simple_intent['folder_name'] == 'ideias'
        
        # 3. Testar execu√ß√£o f√≠sica
        folder_path = Path(temp_workspace) / 'ideias'
        assert not folder_path.exists()  # N√£o deve existir ainda
        
        # Executar comando
        await chat_interface._handle_simple_execution_command(user_input, simple_intent)
        
        # Verificar se pasta foi criada fisicamente
        assert folder_path.exists()
        assert folder_path.is_dir()
        
        print("‚úÖ SUCESSO: Pasta 'ideias' criada fisicamente!")

    @pytest.mark.asyncio
    async def test_nlp_enhanced_patterns(self, mock_gemini_client):
        """Testa padr√µes NLP aprimorados para CREATE_FILE."""
        nlp = NLPEnhanced(mock_gemini_client)
        
        test_cases = [
            ("Crie uma pasta chamada ideias", "create_file", "ideias"),
            ("Quero criar uma nova pasta para documentos", "create_file", "documentos"),
            ("Fa√ßa uma pasta chamada projetos", "create_file", "projetos"),
            ("Criar uma pasta para guardar txt", "create_file", None),  # Deve usar fallback
            ("Nova pasta ideias", "create_file", "ideias"),
        ]
        
        for text, expected_intent, expected_name in test_cases:
            result = await nlp.identify_intent(text)
            print(f"üß† Teste: '{text}' ‚Üí {result}")
            
            assert result['intent'] == expected_intent
            assert result['confidence'] > 60
            
            if expected_name:
                entities = result.get('entities', {})
                # Pode extrair como 'name' ou como detec√ß√£o de contexto
                print(f"   Entidades: {entities}")

    @pytest.mark.asyncio 
    async def test_autonomous_vs_simple_command_routing(self, chat_interface, temp_workspace):
        """Testa roteamento correto entre comandos aut√¥nomos e simples."""
        
        # 1. Comando simples - deve ir para execu√ß√£o direta
        simple_command = "Crie uma pasta chamada docs"
        is_autonomous = await chat_interface._is_autonomous_command(simple_command)
        simple_intent = await chat_interface._identify_simple_execution_intent(simple_command)
        
        print(f"üìù Comando simples: aut√¥nomo={is_autonomous}, simples={simple_intent is not None}")
        
        # Pode ser detectado como aut√¥nomo tamb√©m (que √© OK), mas deve ter intent simples
        assert simple_intent is not None
        
        # 2. Comando complexo - deve ir para sistema aut√¥nomo
        complex_command = "Verifica arquivos, corrige erros, cria fun√ß√£o X, valida tudo"
        is_autonomous_complex = await chat_interface._is_autonomous_command(complex_command)
        simple_intent_complex = await chat_interface._identify_simple_execution_intent(complex_command)
        
        print(f"üîß Comando complexo: aut√¥nomo={is_autonomous_complex}, simples={simple_intent_complex is not None}")
        
        assert is_autonomous_complex == True
        # Comando complexo pode ou n√£o ter intent simples, mas vai para aut√¥nomo primeiro

    @pytest.mark.asyncio
    async def test_command_executor_integration(self, temp_workspace):
        """Testa integra√ß√£o com CommandExecutor."""
        
        # Mock client
        mock_client = Mock()
        executor = CommandExecutor(mock_client)
        
        # Contexto de comando
        context = CommandContext(
            working_directory=str(temp_workspace),
            environment={},
            timeout=30.0,
            safe_mode=True
        )
        
        # Testar comando simples que deve funcionar
        if os.name == 'nt':  # Windows
            test_command = 'echo "Teste Windows"'
        else:  # Linux/Unix
            test_command = 'echo "Teste Linux"'
        
        result = await executor.execute_command(test_command, context)
        
        print(f"üíª Resultado comando: sucesso={result.success}")
        print(f"üì§ Output: {result.stdout}")
        
        assert result.success
        assert "Teste" in result.stdout

    @pytest.mark.asyncio
    async def test_full_integration_create_folder(self, chat_interface, temp_workspace):
        """üöÄ TESTE DE INTEGRA√á√ÉO COMPLETA - Fluxo do usu√°rio real."""
        print("\nüöÄ TESTE INTEGRA√á√ÉO COMPLETA")
        
        # Simular intera√ß√£o completa do usu√°rio
        user_commands = [
            "Crie uma pasta chamada ideias",
            "Fa√ßa uma pasta para documentos", 
            "Nova pasta projetos"
        ]
        
        created_folders = []
        
        for i, command in enumerate(user_commands, 1):
            print(f"\nüìù Comando {i}: {command}")
            
            # Processar atrav√©s do sistema completo
            # Em vez de process_message_with_memory (que vai para Gemini),
            # testamos o fluxo de comandos simples diretamente
            
            # 1. Verificar se √© comando especial
            is_special = await chat_interface._handle_special_commands(command)
            if is_special:
                continue
                
            # 2. Verificar se √© aut√¥nomo
            is_autonomous = await chat_interface._is_autonomous_command(command)
            
            # 3. Verificar se √© comando simples
            simple_intent = await chat_interface._identify_simple_execution_intent(command)
            
            if simple_intent:
                print(f"   ‚ö° Executando como comando simples: {simple_intent}")
                await chat_interface._handle_simple_execution_command(command, simple_intent)
                
                # Verificar se pasta foi criada
                folder_name = simple_intent.get('folder_name', 'unknown')
                folder_path = Path(temp_workspace) / folder_name
                
                if folder_path.exists():
                    created_folders.append(folder_name)
                    print(f"   ‚úÖ Pasta '{folder_name}' criada com sucesso!")
                else:
                    print(f"   ‚ùå Pasta '{folder_name}' N√ÉO foi criada!")
            
            elif is_autonomous:
                print(f"   ü§ñ Seria processado como aut√¥nomo")
            else:
                print(f"   üí¨ Seria processado via Gemini")
        
        print(f"\nüìä RESULTADO FINAL:")
        print(f"‚úÖ Pastas criadas fisicamente: {created_folders}")
        print(f"üìÅ Total: {len(created_folders)}")
        
        # Deve ter criado pelo menos 1 pasta
        assert len(created_folders) >= 1
        
        # Verificar se arquivos existem fisicamente
        for folder_name in created_folders:
            folder_path = Path(temp_workspace) / folder_name
            assert folder_path.exists(), f"Pasta {folder_name} deveria existir!"
            assert folder_path.is_dir(), f"{folder_name} deveria ser diret√≥rio!"

    def test_autonomous_executor_enable_flag(self):
        """Testa se flag enable_real_execution est√° ativa."""
        executor = AutonomousExecutor()
        
        print(f"üîß Flag enable_real_execution: {executor.enable_real_execution}")
        
        # Deve estar True por padr√£o
        assert executor.enable_real_execution == True
        
        # Testar toggle
        executor.enable_execution(False)
        assert executor.enable_real_execution == False
        
        executor.enable_execution(True)
        assert executor.enable_real_execution == True

    @pytest.mark.asyncio
    async def test_delete_command_with_confirmation(self, chat_interface, temp_workspace):
        """Testa comando de dele√ß√£o com confirma√ß√£o."""
        
        # Criar arquivo para testar dele√ß√£o
        test_file = Path(temp_workspace) / "test_file.txt"
        test_file.write_text("conte√∫do de teste")
        assert test_file.exists()
        
        # Comando de dele√ß√£o
        delete_command = "Delete o arquivo test_file.txt"
        
        # Verificar detec√ß√£o
        simple_intent = await chat_interface._identify_simple_execution_intent(delete_command)
        print(f"üóëÔ∏è Comando delete detectado: {simple_intent}")
        
        # Deve detectar como dele√ß√£o
        if simple_intent:
            assert simple_intent['type'] == 'delete'
            assert 'test_file.txt' in simple_intent['target']
        
        # Nota: O teste n√£o executa a dele√ß√£o real porque requereria input do usu√°rio
        print("‚úÖ Comando de dele√ß√£o detectado corretamente (confirma√ß√£o seria solicitada)")

    @pytest.mark.asyncio
    async def test_error_cases_and_edge_cases(self, chat_interface):
        """Testa casos de erro e extremos."""
        
        # 1. Comando vazio
        result = await chat_interface._identify_simple_execution_intent("")
        assert result is None
        
        # 2. Comando sem nome de pasta
        result = await chat_interface._identify_simple_execution_intent("Crie uma pasta")
        # Pode retornar None ou usar nome padr√£o
        print(f"üîç Comando sem nome: {result}")
        
        # 3. Comando com caracteres especiais
        result = await chat_interface._identify_simple_execution_intent("Crie pasta 'minha pasta com espa√ßos'")
        print(f"üî§ Comando com espa√ßos: {result}")
        
        # 4. Comando muito longo
        long_command = "Crie uma pasta " + "muito " * 100 + "longa"
        result = await chat_interface._identify_simple_execution_intent(long_command)
        print(f"üìè Comando longo processado: {result is not None}")


async def run_complete_system_test():
    """üß™ Executa teste completo do sistema de execu√ß√£o."""
    print("üß™ INICIANDO TESTE COMPLETO DO SISTEMA DE EXECU√á√ÉO")
    print("=" * 70)
    print("üéØ Objetivo: Verificar se comandos simples s√£o executados fisicamente")
    print("üîß Baseado nas corre√ß√µes implementadas conforme sugest√µes do Gemini")
    print()
    
    # Executar com pytest para obter relat√≥rio detalhado
    exit_code = pytest.main([
        __file__,
        "-v",
        "--tb=long",
        "-s"  # Mostrar prints
    ])
    
    print("\n" + "=" * 70)
    if exit_code == 0:
        print("üéâ ‚úÖ TODOS OS TESTES PASSARAM!")
        print("üöÄ Sistema de execu√ß√£o real est√° funcionando corretamente!")
        print("üìÅ Comandos simples como 'Crie pasta ideias' agora executam fisicamente!")
    else:
        print("‚ùå ALGUNS TESTES FALHARAM!")
        print(f"üîç C√≥digo de sa√≠da: {exit_code}")
        print("üîß Verifique os logs acima para detalhes dos problemas")
    
    return exit_code


if __name__ == "__main__":
    # Executar teste completo
    exit_code = asyncio.run(run_complete_system_test())
    sys.exit(exit_code)